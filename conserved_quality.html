<canvas id="cells" width=100 height=100></canvas>
<script>
var canvas = document.getElementById('cells');
var graphics = canvas.getContext('2d');

var SIZE = 100;

var cells = {
  water: []
};

var initialize = function() {
  for (var i = 0; i < SIZE; i++) {
    cells.water[i] = [];
    for(var j = 0; j < SIZE; j++) {
      cells.water[i][j] = 0;
    }
  }
}

var offset = 1;
var step = function() {
  
  var relevantArray = cells.water;
  
  // Only loop over every fourth cell (every second row, every second column),
  // as we will look at a four-cell neighbourhood at a time.
  for (var i = 0; i < SIZE; i += 2) {
    for(var j = 0; j < SIZE; j += 2) {
      var x1 = (i + offset) % SIZE;
      var x2 = (i + offset + 1) % SIZE;
      var y1 = (j + offset) % SIZE;
      var y2 = (j + offset + 1) % SIZE;
      
      // Cells in clockwise order (I is horizontal).
      var newValues = updateBlock(
        relevantArray[x1][y1],
        relevantArray[x2][y1],
        relevantArray[x2][y2],
        relevantArray[x1][y2]
      );
      
      // Update, again in clockwise order.
      relevantArray[x1][y1] = newValues[0];
      relevantArray[x2][y1] = newValues[2];
      relevantArray[x2][y2] = newValues[3];
      relevantArray[x1][y2] = newValues[3];
    }
  }
  
  // Alternate between looking up and right versus down and left for the conserved blocks.
  offset = 1 - offset;
}

// How quickly to average out the cells; higher numbers mean faster averaging.
var FLOW_RATE = 0.5;

// Updates a single block of a mass-conserving cellular automatom.
// a, b, c, and d are four cell values in clockwise order (orientation not guaranteed);
// the returned value should be an array with their four new values
// in the same order. To maintain conservation of mass, the sum of
// the returned array should be the same as for the original four values.
var updateBlock = function(a, b, c, d) {

  // Take from the higher values, give to the lower ones.
  var values = [a, b, c, d];

  for (var i = 0; i < values.length; i++) {

    // Relying on loop condition to not run the loop if i+1 is out of bounds.
    for (var j = i + 1; j < values.length; j++) {

      // Flow at a rate proportional to the difference.
      var difference = Math.abs(values[i] - values[j]);
      var flow = Math.floor(difference * FLOW_RATE);

      if (values[i] > values[j]) {
        values[i] -= flow;
        values[j] += flow;
      }
      if (values[i] < values[j]) {
        values[i] += flow;
        values[j] -= flow;
      }
    }
  }

  return values;


  // Distribute the total mass evenly across all cells.
  //var total = a + b + c + d;
  //var average = Math.floor(total / 4);
  //var error = total - (average * 4);
  //
  //return [average + error, average, average, average];
}

var render = function(graphicsContext) {

  var palette = { r: 0, g: 0, b: 1 };
  
  var relevantArray = cells.water;
  for (var i = 0; i < SIZE; i++) {
    for(var j = 0; j < SIZE; j++) {
    
      // Need integer values for CSS "rgb()" function.
      var rInt = Math.floor(palette.r * relevantArray[i][j]);
      var gInt = Math.floor(palette.g * relevantArray[i][j]);
      var bInt = Math.floor(palette.b * relevantArray[i][j]);
      var colourString = 'rgb(' + rInt + ',' + gInt + ',' + bInt + ')';
      
      graphicsContext.fillStyle = colourString;
      graphicsContext.fillRect(i, j, 1, 1);
    }
  }
};

initialize();

// Add some inital water so we can see it flow.
cells.water[50][50] = 255;

// Add water on click.
canvas.onclick = function(event) {
  var canvasX = event.pageX - canvas.offsetLeft;
  var canvasY = event.pageY - canvas.offsetTop;
  var oldValue = cells.water[canvasX][canvasY];

  cells.water[canvasX][canvasY] = Math.min(oldValue + 100, 255);
};

render(graphics);

window.setInterval(function() {
  step();
  render(graphics);
}, 500);
</script>
